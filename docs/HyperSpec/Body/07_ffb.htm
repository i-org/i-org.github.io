<!DOCTYPE html>
<HTML>
<HEAD><meta http-equiv="content-type" content="text/html; charset=utf-8">
<TITLE>CLHS: Section 7.6.6.2</TITLE>
<LINK HREF="../Data/style.css" REL="stylesheet" TYPE="text/css" />
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="LispWorks Ltd.">
<LINK REL=TOP HREF="../Front/index.htm">
<LINK REL=COPYRIGHT HREF="../Front/Help.htm#Legal">
<LINK REL=DISCLAIMER HREF="../Front/Help.htm#Disclaimer">
<LINK REL=PREV HREF="07_ffac.htm">
<LINK REL=UP HREF="07_ff.htm">
<LINK REL=NEXT HREF="07_ffc.htm">
</HEAD>
<BODY>
<h1><A REL=TOP HREF="../Front/index.htm">《通链参考手册》</A> <A REL=PREV HREF="07_ffac.htm">◀</A><A REL=UP HREF="07_ff.htm">▲</A><A REL=NEXT HREF="07_ffc.htm">▶</A></H1>

<HR>

<H2>
7.6.6.2 Standard Method Combination</H2>  <A NAME="standard"></A> <P>
Standard method combination is supported by the <A REL=DEFINITION HREF="26_glo_c.htm#class"><I>class</I></A> <A REL=DEFINITION HREF="t_std_ge.htm#standard-generic-function"><B>standard-generic-function</B></A>. It is used if no other type of method combination is specified or if the built-in method combination type <A REL=DEFINITION HREF="#standard"><B>standard</B></A> is specified. <P>
Primary methods define the main action of the effective method, while auxiliary methods modify that action in one of three ways. A primary method has no method <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifiers</I></A>. <P>
An auxiliary method is a method whose <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A> is <b>:before</b>, <b>:after</b>, or <b>:around</b>. Standard method combination allows no more than one <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A> per method; if a method definition specifies more than one <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A> per method, an error is signaled. <P>
<P><ul><P>
<li>*  A <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before method</I></A> has the keyword <b>:before</b> as its only <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A>. A <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before method</I></A> specifies <A REL=DEFINITION HREF="26_glo_c.htm#code"><I>code</I></A> that is to be run before any <A REL=DEFINITION HREF="26_glo_p.htm#primary_method"><I>primary methods</I></A>. <P></li>
<li>*  An <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after method</I></A> has the keyword <b>:after</b> as its only <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A>. An <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after method</I></A> specifies <A REL=DEFINITION HREF="26_glo_c.htm#code"><I>code</I></A> that is to be run after <A REL=DEFINITION HREF="26_glo_p.htm#primary_method"><I>primary methods</I></A>. <P></li>
<li>*  An <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> has the keyword <b>:around</b> as its only <A REL=DEFINITION HREF="26_glo_q.htm#qualifier"><I>qualifier</I></A>. An <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> specifies <A REL=DEFINITION HREF="26_glo_c.htm#code"><I>code</I></A> that is to be run instead of other <A REL=DEFINITION HREF="26_glo_a.htm#applicable_method"><I>applicable methods</I></A>, but which might contain explicit <A REL=DEFINITION HREF="26_glo_c.htm#code"><I>code</I></A> which calls some of those <I>shadowed</I> <A REL=DEFINITION HREF="26_glo_m.htm#method"><I>methods</I></A> (via <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A>). <P></li>
<P></ul><P>
The semantics of standard method combination is as follows: <P>
<P><ul><P>
<li>*  If there are any <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around methods</I></A>, the most specific <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> is called. It supplies the value or values of the generic function. <P></li>
<li>*  Inside the body of an <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A>, <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> can be used to call the <A REL=DEFINITION HREF="26_glo_n.htm#next_method"><I>next method</I></A>. When the next method returns, the <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> can execute more code, perhaps based on the returned value or values. The <A REL=DEFINITION HREF="26_glo_g.htm#generic_function"><I>generic function</I></A> <A REL=DEFINITION HREF="f_no_nex.htm#no-next-method"><B>no-next-method</B></A> is invoked if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is used and there is no <A REL=DEFINITION HREF="26_glo_a.htm#applicable_method"><I>applicable method</I></A> to call. The <A REL=DEFINITION HREF="26_glo_f.htm#function"><I>function</I></A> <A REL=DEFINITION HREF="f_next_m.htm#next-method-p"><B>next-method-p</B></A> may be used to determine whether a <A REL=DEFINITION HREF="26_glo_n.htm#next_method"><I>next method</I></A> exists. <P></li>
<li>*  If an <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> invokes <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A>, the next most specific <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> is called, if one is applicable. If there are no <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around methods</I></A> or if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is called by the least specific <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A>, the other methods are called as follows: <P></li><ul><li>--  All the <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before methods</I></A> are called, in most-specific-first order. Their values are ignored. An error is signaled if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is used in a <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before method</I></A>. <P></li>
<li>--  The most specific primary method is called. Inside the body of a primary method, <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> may be used to call the next most specific primary method. When that method returns, the previous primary method can execute more code, perhaps based on the returned value or values. The generic function <A REL=DEFINITION HREF="f_no_nex.htm#no-next-method"><B>no-next-method</B></A> is invoked if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is used and there are no more applicable primary methods. The <A REL=DEFINITION HREF="26_glo_f.htm#function"><I>function</I></A> <A REL=DEFINITION HREF="f_next_m.htm#next-method-p"><B>next-method-p</B></A> may be used to determine whether a <A REL=DEFINITION HREF="26_glo_n.htm#next_method"><I>next method</I></A> exists. If <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is not used, only the most specific <A REL=DEFINITION HREF="26_glo_p.htm#primary_method"><I>primary method</I></A> is called. <P></li>
<li>--  All the <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after methods</I></A> are called in most-specific-last order. Their values are ignored. An error is signaled if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is used in an <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after method</I></A>. <P></li></ul><li>*  If no <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around methods</I></A> were invoked, the most specific primary method supplies the value or values returned by the generic function. The value or values returned by the invocation of <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> in the least specific <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> are those returned by the most specific primary method. <P></li>
<P></ul><P>
In standard method combination, if there is an applicable method but no applicable primary method, an error is signaled. <P>
The <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before methods</I></A> are run in most-specific-first order while the <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after methods</I></A> are run in least-specific-first order. The design rationale for this difference can be illustrated with an example. Suppose class C1 modifies the behavior of its superclass, C2, by adding <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before methods</I></A> and <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after methods</I></A>. Whether the behavior of the class C2 is defined directly by methods on C2 or is inherited from its superclasses does not affect the relative order of invocation of methods on instances of the class C1. Class C1's <A REL=DEFINITION HREF="26_glo_b.htm#before_method"><I>before method</I></A> runs before all of class C2's methods. Class C1's <A REL=DEFINITION HREF="26_glo_a.htm#after_method"><I>after method</I></A> runs after all of class C2's methods. <P>
By contrast, all <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around methods</I></A> run before any other methods run. Thus a less specific <A REL=DEFINITION HREF="26_glo_a.htm#around_method"><I>around method</I></A> runs before a more specific primary method. <P>
If only primary methods are used and if <A REL=DEFINITION HREF="f_call_n.htm#call-next-method"><B>call-next-method</B></A> is not used, only the most specific method is invoked; that is, more specific methods shadow more general ones. <P>
<HR>

<a href="../Front/index.htm"> ◇首页 </A> § <a href="../Front/Contents.htm"> ◎章节目录 </a> § <a href="../Front/X_Master.htm"> □内容索引 </a> § <a  href="../Front/X_Symbol.htm"> ○符号索引 </a> § <a href="../Body/26_a.htm"> △术语表 </a> § <a href="../Issues/I_Categ.htm"> ※设计草案 </a><hr>

<div class="footer"><a rel=copyright href="../Front/Help.htm#Legal"><i>2012 此修改版放弃所有版权</i></a></div>
</BODY>
</HTML>
